//----------------------------------------------------------------------
// Best viewed with tabs every 4 columns
//----------------------------------------------------------------------
import java.util.*;

/**
 * Determines whether a string can be generated by a given set of
 * production rules.
 *
 * We are given a collection of production rules of the form "x --> yz",
 * meaning that the character x can be replaced with the string "yz".
 * Given such a collection of rules, and a pair consisting of an input
 * symbol and an output string, and the question is there a way to
 * generate the output string through a series of substitutions to the
 * input symbol. If so, a derivation of the sequence is to be output.
 */
public class Main {

	/** 
	 *  Main program
	 *
	 *	Here is the input format:
	 *			<number of cases>
	 *			(Repeat the following for each case)
	 *				<lhs>  <rhs>	(the production "lhs --> rhs"
	 *				<lhs>  <rhs>
	 *				...
	 *				$				(marks end of productions)
	 *				<start>			(start symbol)
	 *				<target>		(target string)
	 *
	 *	The programmer provides computeDerivation, which determines
	 *	whether it is possible to derive the target from the start
	 *	symbol. (See below.)
	 */
	public static void main(String[] args) throws Exception {
											// read input
		Scanner scanner = new Scanner(System.in);
		int nTests = scanner.nextInt();		// number of test cases

		for (int t = 0; t < nTests; t++) {
			System.out.println("Test case: " + t);
											// productions "lhs --> rhs"
			ArrayList<Character> lhs = new ArrayList<Character>();
			ArrayList<String> rhs = new ArrayList<String>();
											// input next lhs
			Character l = nextCharacter(scanner);
			while (l.charValue() != '$') {	// not yet finished
				lhs.add(l);					// add new lhs
				String r = scanner.next();	// next rhs
				rhs.add(r);					// add new rhs
				l = nextCharacter(scanner);	// input next lhs
			}
			//summarizeProductions(lhs, rhs);	// summarize productions
											// start symbol
			Character start = nextCharacter(scanner);
			while (start.charValue() != '#') {	// not yet done
				String target = scanner.next();	// target string
											// compute derivation
				ArrayList<Integer> derivation =
					computeDerivation(lhs, rhs, start, target);
				checkAndSummarizeResult(lhs, rhs, start, target, derivation);
											// get next start
				start = nextCharacter(scanner);
			}
			System.out.println();
		}
	}

	/** 
	 *  Utility that reads a single character string
	 */
	private static Character nextCharacter(Scanner scanner) {
		String x = scanner.next();
		if (x.length() != 1) {
			System.out.println("Error: Expecting a single character");
			System.exit(0);
		}
		return new Character(x.charAt(0));
	}
	
	/** 
	 *  Summarize input
	 */
	private static void summarizeProductions(
			ArrayList<Character> lhs,		// left-hand-sides
			ArrayList<String> rhs)			// corresponding right-hand-sides
	{
		System.out.println("  Productions: (lhs --> rhs)");
		int nr = lhs.size();				// number of rules
		if (nr != rhs.size()) {
			System.out.println("Error: lhs and rhs must have equal length");
			System.exit(0);
		}
		for (int i = 0; i < nr; i++) {
			System.out.println("    [" + i + "]: " + lhs.get(i) + " --> " + rhs.get(i));
			if (rhs.get(i).length() != 2) {
				System.out.println("Error: rhs must be two characters");
				System.exit(0);
			}
		}
		System.out.println();
	}
	
	/** 
	 *  Summarize derivation and verify its correctness
	 */
	private static void checkAndSummarizeResult(
			ArrayList<Character> lhs,		// left-hand-sides
			ArrayList<String> rhs,			// corresponding right-hand-sides
			Character start,				// start symbol
			String target,					// target string
			ArrayList<Integer> derivation)	// derivation
	{
		int n = target.length();			// target size
		int nr = lhs.size();				// number of rules
		int m = derivation.size()/2;		// length of derivation
		System.out.print("  Derive \"" + target + "\" from \"" + start + "\"? ");
		if (m == 0) {						// empty derivation?
			if (target.length() == 1 &&		// okay, if target == start
				start.charValue() == target.charAt(0)) {
				System.out.println("YES! (trivially)");
			}
			else {							// otherwise, no derivation
				System.out.println("NO!");
			}
		}
		else {								// nontrivial derivation
			System.out.println("YES!");

			/*System.out.print("    Derivation: ");
			for (int i = 0; i < m; i++) {	// print it
				System.out.print("(" + derivation.get(2*i) + "," + derivation.get(2*i+1) + ") ");
			}
			System.out.println();*/

			StringBuffer current = new StringBuffer();
			current.append(start);			// current = start symbol
			for (int i = 0; i < m; i++) {
				int r = derivation.get(2*i);	// get rule
				int p = derivation.get(2*i + 1);// get application index
				if (r < 0 || r >= nr) {		// check rule index for validity
					System.out.println("Error - rule index " + r + " is out of bounds");
					System.exit(0);
				}
											// rule: s --> x y
				char s = lhs.get(r).charValue();
				String thisRhs = rhs.get(r);
				char x = thisRhs.charAt(0);
				char y = thisRhs.charAt(1);
											// check application index validity
				if (p < 0 || p >= current.length()) {
					System.out.println("Error - application index " + p + " is out of bounds");
					System.exit(0);
				}
											// check rule application validity
				if (s != current.charAt(p)) {
					System.out.println("Error - attempt to apply rule for " + s + " but character is " + current.charAt(p));
					System.exit(0);
				}
											// make current substitution
				current.replace(p, p+1, rhs.get(r));
				//System.out.print("      Apply[" + r + "] at " + p + ": ");
				//if (i == 0) System.out.print("S");
				//else System.out.print(" ");
				//System.out.println( " ==> " + current);
			}
			if (!current.toString().equals(target)) {
				System.out.println("Error - derivation does not yield target");
				System.exit(0);
			}
		}
	}
	 
	/** 
	 *  computeDerivation
	 *
	 *	Given a list of productions, a start symbol, and a target
	 *	string, this function determines whether it is possible to
	 *	derive the target from the start symbol using the productions.
	 *	It returns an ArrayList of Integers, of length 2*m, where m is
	 *	the number of steps in the derivation. If no derivation is
	 *	possible, or if start == target, this ArrayList is empty.
	 *	Otherwise, its entries come in pairs, where the first of each
	 *	pair indicates which production rule is to be applied, and the
	 *	second indicates the index of the current string at which to
	 *	apply the rule. (All indexing starts at 0.)
	 */

/*
	private static ArrayList<Integer> computeDerivation(
			ArrayList<Character> lhs,		// left-hand-sides
			ArrayList<String> rhs,			// corresponding right-hand-sides
			Character start,				// start symbol
			String target)					// target string
	{
		--- Add you code here ---
	}
*/

//----------------------------------------------------------------------
// The following is hidden from the contestants.
//----------------------------------------------------------------------
	
	/** 
	 *  Derivation table entry
	 *
	 *  The DP formulation involves a table of derivation entries, each
	 *  containing an lhs symbol, the index of a production rule, and
	 *  a partition index. When a rule "s --> x y" is applied, the
	 *  partition index where in the string x ends.
	 */
	private static class Entry {
		public char symb;					// generating symbol
		public int rule;					// production rule index
		public int part;					// partition index
		public Entry(char s, int r, int p)	// constructor
			{ symb = s; rule = r; part = p; }
		public boolean equals(Entry e)		// equality test
			{ return symb == e.symb && rule == e.rule && part == e.part; }
	};
	
	/** 
	 *  Derivation list
	 *
	 *  A list of derivation table entries. We provide a method that
	 *  returns an entry whose symbol matches a given value.
	 */
	private static class DerivationList extends ArrayList<Entry> {
		public Entry matchSymbol(char s) {
			boolean found = false;
			for (Entry e : this) {			// search the list
				if (e.symb == s) return e;	// found it?
			}
			return null;					// failed search
		}
	};
	
	/** 
	 *  Compute derivation
	 *
	 *  Computes a derivation of a given target string from a given
	 *  start symbol and a grammar. Our algorithm is a variant of the
	 *  Cocke-Younger-Kasami algorithm which determines whether a string
	 *  can be derived from a given context-free grammar given in
	 *  Chomsky normal form. Our derivation rules are of this form. Here
	 *  is a pseudocode description of the CYK Algorithm.
	 *
	 *  Input:
	 *    Start symbol: s
	 *    Target string: T = t1 ... tn
	 *    Grammar: nr rules, each of the form a --> b c
	 *
	 *  Method:
	 *    First, we compile a symbol table of all the symbols appearing
	 *    in all the strings, and we encode each string as an array of
	 *    integers, where the integer is the index of the symbol.

	 *    The parsing algorithm is a standard application of dynamic
	 *    programming. We compute a table D[n,n], where, D[i,j] contains
	 *    a list of entries (s,l,p), each of which consists of a symbol
	 *    s that generates the substring T[i..j], the index l of
	 *    first rule "s --> x y" in the derivation of the substring, and
	 *    the partition index p, such that x generates T[i..p] and y
	 *    generates T[p+1..j].
	 *
	 *    We generate the table as follows. For each i and j, in
	 *    increasing order of span j-i, we enumerate all p between
	 *    i and j-1, we check whether there is any rule s --> x y such
	 *    that x is in D[i,p], y is in D[p+1,j]. If so, we add s, the
	 *    rule index and p to D[i,j].
	 *
	 *  Pseudocode:
	 *    for i = 0 ... n-1
	 *      set D[i,i] = (T[i],-,-)
	 *      for j = i+1 ... n-1
	 *        set D[i,j,k] = empty
	 *
	 *    for k = 2 ... n (Length of span) {
	 *      for i = 0 ... n-k (Start of span) {
	 *        j = i + k - 1 (End of span)
	 *        for p = i ... j-1 (Partitioning index) {
	 *          for r = 0 ... nr-1 (Enumerate each rule) {
	 *            let the r-th rule be s --> x y
	 *            if (x is in D[i,p] and y is in D[p+1,j]) {
	 *              add (s,r,p) to D[i,j]
	 *            }
	 *          }
	 *        }
	 *      }
	 *    }
	 *    if s is in D[0,n-1], where s is the start symbol then
	 *      "T can be generated from s" -- compute the derivation
	 *    else
	 *      "T cannot be generated from s" -- return empty derivation
	 */
	private static ArrayList<Integer> computeDerivation(
			ArrayList<Character> lhs,		// left-hand-sides
			ArrayList<String> rhs,			// corresponding right-hand-sides
			Character start,				// start symbol
			String target)					// target string
	{
		int n = target.length();			// length of target
		int nr = lhs.size();				// number of rules
											// allocate DP table
		DerivationList[][] D = new DerivationList[n][n];

		for (int i = 0; i < n; i++) {		// initialize the table
			for (int j = 0; j < n; j++) {
				D[i][j] = new DerivationList();
			}
			D[i][i].add(new Entry(target.charAt(i), 0, 0));
		}

											// compute the DP table
		for (int k = 2; k <= n; k++) {			// length of span
			for (int i = 0; i <= n-k; i++) {	// start of span
				int j = i+k-1;					// end of span
				for (int p = i; p < j; p++) {	// partitioning index
					for (int r = 0; r < nr; r++) {// rules
						char s = lhs.get(r).charValue();	// rule: s --> x y
						char x = rhs.get(r).charAt(0);
						char y = rhs.get(r).charAt(1);
						Entry ex = D[i][p].matchSymbol(x);
						Entry ey = D[p+1][j].matchSymbol(y);
												// found matching symbols?
						if (ex != null && ey != null) {
							D[i][j].add(new Entry(s, r, p));
						}
					}
				}
			}
		}
											// is derivation possible?
		Entry e = D[0][n-1].matchSymbol(start.charValue());
		if (e == null) {					// no - return empty derivation
			return new ArrayList<Integer>();
		}
		else {								// yes - extract from table
			return extractDerivation(0, n-1, D, start.charValue(), target, lhs, rhs);
		}
	}

	/** 
	 *  Extract derivation from DP table
	 *
	 *    Extracts the final derivation from the DP table. This is
	 *    performed recursively. The call extract(i, j, ss) generates a
	 *    derivation list to produce the string target[i..j] from symbol
	 *    ss. The initial call is extract(0, n-1, start).
	 *
	 *    extract(i, j, ss):
	 *      if (i == j) return
	 *      find an entry e = (ss, r, p) in D[i,j]  (it must exist)
	 *      let the r-th rule be: ss --> x y
	 *      L = { (r, i) }
	 *      L1 = extract(i, p, x)
	 *      L2 = extract(p+1, j, y)
	 *      return L + L1 + L2
	 */
	private static ArrayList<Integer> extractDerivation(
			int i,							// start of span
			int j,							// end of span
			DerivationList[][] D,			// the DP table
			char ss,						// generating symbol
			String target,					// target string
			ArrayList<Character> lhs,		// left-hand-sides
			ArrayList<String> rhs)			// corresponding right-hand-sides
	{
											// derivation storage
		ArrayList<Integer> L =  new ArrayList<Integer>();
		if (i == j) {						// single character
			if (ss != target.charAt(i)) {	// consistency check
				System.out.println("Internal error - derivation failed");
				System.exit(0);
			}
		}
		else {								// get matching derivation entry
			Entry e = D[i][j].matchSymbol(ss);
			if (e == null) {				// no valid entry?
				System.out.println("Internal error - derivation failed");
				System.exit(0);
			}
			int r = e.rule;					// derivation rule
			int p = e.part;					// partition index
			L.add(r); L.add(i);				// add these to derivation
			char s = lhs.get(r).charValue();// rule: s --> x y
			char x = rhs.get(r).charAt(0);
			char y = rhs.get(r).charAt(1);
			if (s != ss) {
				System.out.println("Internal error - derivation failed");
				System.exit(0);
			}
			ArrayList<Integer> L1 = extractDerivation(i,p,D,x,target,lhs,rhs);
			ArrayList<Integer> L2 = extractDerivation(p+1,j,D,y,target,lhs,rhs);
			L.addAll(L1);				// final derivation = L + L1 + L2
			L.addAll(L2);
		}
		return L;						// return derivation
	}

	/** 
	 *  Print the DP table (for debugging)
	 */
	private static void printTable(
			DerivationList[][] D,			// derivation
			String target,					// target string
			ArrayList<Character> lhs,		// left-hand-sides
			ArrayList<String> rhs)			// corresponding right-hand-sides
	{
		System.out.println("Table:");
		for (int i = 0; i < D.length; i++) {
			System.out.println("[" + i + "]: ");
			for (int j = i; j < D[i].length; j++) {
				System.out.print("  [" + j + "] = \"" + target.substring(i, j+1) + "\" ");
				for (int k = 0; k < D[i][j].size(); k++) {
					Entry e = D[i][j].get(k);
					char s = e.symb;
					int r = e.rule;
					int p = e.part;
					System.out.print("(");
					if (i == j) {
						System.out.print(s + " --> " + s);
					}
					else {
						System.out.print("[" + r + "]:" +
							lhs.get(r) + " --> " + rhs.get(r) + " -> " +
							target.substring(i,p+1) + "|" + target.substring(p+1,j+1));
					}
					System.out.print(") ");
				}
				System.out.println();
			}
		}
	}
}
